# 문제설명
영문 소문자로 구성된 문자열 S에 배열 C를 차례대로 하나씩 꺼낸 c를 인덱스로 '$' 문자를 삽입할 것입니다.
예를 들어, S = "aabcba" 및 C = [1, 3, 2]가 주어지면 S에 세 개의 '$' 문자를 삽입하여 다음 문자열을 얻습니다. "a$abcba" → "a$ab$cba" → "a$a$b$cba".

추가된 '$'로 끊었을 때 끊어진 문자열에서 중복된 알파벳이 없을 때까지 진행합니다. 목표를 이루기 위해 진행해야하는 C 배열의 최소 단계 수를 반환합니다.
단, 배열을 돌기 전에 이미 중복 알바벳이 없다면 0을, 다 돌아도 여전히 중복값이 있을 때는 -1를 반환합니다. 

 S = "aabcba" 및 C = [1, 3, 2]
"a$abcba" → "a$ab$cba" → "a$a$b$cba".

위의 예에서 두 번째 삽입 후에는 '$'로 끊긴 'a','ab','cba'에 중복된 알파벳이 없습니다. 따라서 답은 2입니다.

예:

1. S = "aabcba" 및 C = [1, 3, 2]가 주어지면 위에서 설명한 대로 함수는 2를 반환해야 합니다.

2. S = "aaa" 및 C = [1, 2]가 주어지면 함수는 2를 반환해야 합니다.
"aaa" → "a$aa" → "a$a$a".

3. 주어진 S = "aabcddcb" 및 C = [3, 5, 1, 4, 7], 함수는 3을 반환해야 합니다.
"aabcddcb" → "aab$cddcb" → "aab$cd$dcb" → "a$ab$cd$dcb".

4. 주어진 S = "wkwk" 및 C = [1], 함수는 -1을 반환해야 합니다. 유일한 삽입 후 문자 'k'는 발생 사이에 '$' 문자가 없습니다: "w$kwk".

5. 주어진 S = "abcd" 및 C = [1, 2], 함수는 0을 반환해야 합니다. '$' 문자를 삽입할 필요가 없습니다.

다음 가정에 대한 효율적인 알고리즘을 작성하십시오.

영문 소문자로 구성된 길이는 [2..50,000] 범위 내의 정수입니다.
문자열 S는 소문자(a-z)로만 구성됩니다.
C의 요소는 모두 별개입니다.
배열 C의 각 요소는 [1..N-1] 범위 내의 정수입니다.